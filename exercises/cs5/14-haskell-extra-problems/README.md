## допълнителни задачи (haskell)

**Зад. 1а:** Дефинирайте тип от данни `Task`, който представя задача,
която трябва да бъде свършена в даден проект. Задачата трябва да има
**име** и **статус**. Възможните стойности на статуса трябва да са *завършена* и *незавършена*.

**Зад. 1b:** Дефинирайте тип от данни `TaskGraph`, който представя
граф от задачи. Ребро в графа означава, че дадена задача се блокира от друга.

**Зад. 1c:** Дефинирайте функцията `taskOrder :: TaskGraph -> Maybe [Task]`,
която връща списък от всички задачи от графа, подредени в ред,
в който могат да бъдат изпълнени така, че всяка задача да се изпълнява
след всички, от които е блокирана. Ако в графа има цикъл, функцията да
връща `Nothing`

**Зад. 2:** Дефинирайте функция `movingAverage`, която по дадени число `n` и безкраен поток от `Float`
числа връща безкраен поток от [пълзящите средни стойности](https://en.wikipedia.org/wiki/Moving_average) на дадения поток с прозорец `n`.

**Зад. 3a:** Дефинирайте рекурсивен тип от данни `ArithExpr`, който представя
аритметичен израз, поддържащ:
- константни стойности от тип `Float`
- операции събиране, изваждане, умножение, деление и степенуване
- променливи с имена от тип `String`

**Зад. 3b:** Дефинирайте функцията `calculate :: [(String, Float)] -> ArithExpr -> Maybe Float`, която пресмята стойността на даден
аритметичен израз, използвайки таблица с дадени стойности на променливи

**Зад. 3c:** Дефинирайте функцията `differentiate :: String -> ArithExpr -> ArithExpr`, която диференцира
даден аритметичен израз по дадена променлива
