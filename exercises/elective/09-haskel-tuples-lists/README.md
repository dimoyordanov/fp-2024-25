# 09. Кортежи и Списъци


## λ-функции

```haskell
f x y z = x + y + z
f = \x y z -> x + y + z
f = \x -> \y -> \z -> x + y + z
```

## Кортежи (tuples)

```haskell
x :: (Int, Double, String)
x = (2, 3.14, "foo")
```

- Полезни функции: `fst`, `snd`
> [!NOTE]
> `fst` и `snd` работят само върху наредени **двойки**


## Списъци (lists)

> [!NOTE]
> Както при `scheme`, така и тук списък наричаме или "наредена двойка" от нещо списък (`:`) или константата "празен списък" (`[]`).

```scheme
'(1 2 3)
(cons 1 (cons 2 (cons 3 '())))
```

```haskell
1 : 2 : 3 : []
1 : 2 : [3]
1 : [2, 3]
[1, 2, 3]
```

> [!NOTE]
> Tъй като `haskell` е мързелив език списъците в `haskell` съответстват на потоци в `scheme`. Това ни позволява да дефинираме "безкрайни" списъци по съвсем естествен начин.

```haskell
ones :: [Integer]
ones = 1 : ones
```

**Въпрос**: Защо в `scheme` имаме само наредени двойки, докато в `haskell` има _кортежи_ и _списъци_?


### Примери за функции върху списъци

```haskell
cons :: a -> [a] -> [a]
cons x xs = x : xs

null' :: [a] -> Bool
null' [] = True
null' _  = False

sum' :: _ -- Какъв е типа на sum?
sum' [] = 0
sum' (x : xs) = x + sum' xs

map' :: _ -- Какъв е типа на map?
map' _ []     = []
map' f (x:xs) = (f x) : (map' f xs)

filter' :: _ -- Какъв е типа на filter?
filter' _ [] = []
filter' p (x:xs)
  | p x       = x : filter' p xs
  | otherwise = filter' p xs
```


### List comprehension

Освен класическото `[1, 2, 3]` можем да изразяваме списъци чрез т.нар. "set builder notation" (от теорията на множествата), а именно

```haskell
evens xs = [x | x <- xs, x `rem` 2 == 0]
-- четем: "четните елемент на xs са всички x-ове, които идват от xs и се делят на 2 с остатък 0"
```

Инсрументариумът ни се състои от следните неща:

1. `[... | ..., m <- f x y z,...]`, където `f x y z :: [a]` и `m :: a`, а `x`, `y` и `z` или са външни променливи, или са дефинирани подобно по-наляво от `m`
2. `[... | ..., p, ...]`, където `p :: Bool`
3. `[f x y z ... | ...]`, където `x`, `y` и `z` са дефинирани по правило 1

```haskell
pairs xs ys = [(x, y) | x <- xs, y <- ys]
-- четем: "... са всички наредени двойки (x, y), където x идва от xs, а y идва от ys"

-- >>> pairs [1,2] ["a", "b"]
-- [(1, "a"), (1, "b"), (2, "a"), (2, "b")]
```

Забележете реда, в който се избира елемент от `xs` и от `ys`. Ако имахме:

```haskell
pairs xs ys = [(x, y) | y <- ys, x <- xs]
-- >>> pairs [1,2] ["a", "b"]
-- [(1, "a"), (2, "a"), (1, "b"), (2, "b")]
```

```haskell
matrix :: Int -> Int -> [[(Int, Int)]]
matrix rows cols = [[(row, col) | col <- [1..cols]] | row <- [1..rows]]
-- четем: "... е всичките редове (всичките (row, col), където col идва от [1..cols]), където row идва от [1..rows]"

-- >>> matrix 3 4
-- [ [(1, 1), (1, 2), (1, 3), (1, 4)]
-- , [(2, 1), (2, 2), (2, 3), (2, 4)]
-- , [(3, 1), (3, 2), (3, 3), (3, 4)]
-- ]
```

> [!NOTE]
> "Операциите" в list comprehension-а се случват "линейно" (отляво-надясно): `[x | x <- xs, even x]` е валидно, докато `[x | even x, x <- xs]` не е


## Задачи:

Дефинирайте следните функции работещи върху списъци. Измислете техните типове, по-възможност колкото може по-общи:

> [!NOTE]
> Понеже някои от тези функции ги има вече в прелюдието, то ще трябва изрично да ги "скрием", че да можем да ги имплементираме ние:
> ```haskell
> import Prelude hiding (length, foldr, foldl, reverse, init, product, zip, zipWith)
> ```

> [!NOTE]
> Ако се затруднявате с типовете на функциите пробвайте първо да ги имплементирате само за Int-ове, а след като ги имплементирате може да помислите как могат да се генаранизират

1. Намира дължината на списъка `xs`

```haskell
length :: _
length xs = undefined
```

2. Проверява дали съществува елемент в `xs`, за който е изпълнен предикатът `p` (мислете `any`)

```haskell
exists :: _
exists p xs = undefined
```

3. Проверява дали предикатът `p` е изпълнен за всички елементи на списъка `xs` (мислете `all`)

```haskell
forall :: _
forall p xs = undefined
```

4. Проверява дали елементът `x` се съдържа в списъка `xs` (какво значи "съдържа"?)

```haskell
member :: _
member x xs = undefined
```

5. Добавя елемента `x` на края на списъка `xs`

```haskell
push :: _
push x xs = undefined
```

6. Връща списък с елементите на `xs` в обратен ред

```haskell
reverse :: _
reverse xs = undefined
```

7. Връща списък с всички елементи на `xs` без последния

```haskell
init :: _
init xs = undefined

-- >>> init [1, 2, 3, 4]
-- [1, 2, 3]
```

8. Вкарва елемента `x` на позиция `n` в списъка `xs` (ако `n` е след края на `xs`, вкарваме `x` накрая)

```haskell
insert :: _
insert x n xs = undefined
```

9. Пресмята `op xs[0] (op xs[1] (op xs[2] ... (op xs[n] init) ... )))` (ако имаме подаден празен списък, резултатът е `init`).

```haskell
foldr :: _
foldr op init xs = undefined
```

10. Пресмята `op ( ... (op (op (op xs[0]) xs[1]) xs[2]) ... xs[n] ) init` (ако имаме подаден празен списък, резултатът е `init`).

```haskell
foldl :: _
foldl op init xs = undefined
```

11. Намира произведението на елементите в списък от числа

```haskell
product :: _
product = undefined
```

12. "зип"-ва два списъка заедно (в наредени двойки)

```haskell
zip :: _
zip = undefined

-- >>> zip [1,2,3] ["a", "b", "c"]
-- [(1, "a"), (2, "b"), (3, "c")]
```

13. "зип"-ва два списъка заедно, използвайки комбинираща функция

```haskell
zipWith :: _
zipWith = undefined

-- >>> zipWith (+) [1, 2, 3] [2, 4, 6]
-- [3, 6, 9]
```

14. Списък, получен от zig-zag-ването на два други такива

```haskell
interleave :: _
interleave = undefined

-- >>> interleave [1,2,3] [4,5,6]
-- [1, 4, 2, 5, 3, 6]

-- >>> interleave nats (map (*2) nats)
-- [1, 2, 2, 4, 3, 6, 4, 8, 5, 10, 6, 12,  ...]

-- >>> interleave (filter odd nats) (filter even nats)
-- [1, 2, 3, 4, 5, 6, ...]
```

### Безкрайни списъци (потоци)

15. Списък от всички естествени числа

```haskell
nats :: _
nats = undefined

-- >>> take 10 nats
-- [1,2,3,4,5,6,7,8,9,10]
```

16. Списъкът от всички питагорови тройки (ползвайте list comprehension)

```haskell
pythagoreanTriples :: _
pythagoreanTriples = undefined

-- >>> take 5 pythagoreanTriples
-- [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
```

17. Списък от всички числа от редицата на Фибоначи:

```haskell
fibs :: _
fibs = undefined

-- >>> take 8 fibs
-- [0,1,1,2,3,5,8,13]
```

18. Списъкът от всички прости чиста, позовавайки се на ["решетото на Ератостен"](https://bg.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D0%B5%D1%82%D0%BE_%D0%BD%D0%B0_%D0%95%D1%80%D0%B0%D1%82%D0%BE%D1%81%D1%82%D0%B5%D0%BD)

```haskell
primes :: _
primes = undefined

-- >>> take 10 primes
-- [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```
